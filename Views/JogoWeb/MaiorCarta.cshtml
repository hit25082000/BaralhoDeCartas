@model BaralhoDeCartas.Models.Interfaces.IJogoMaiorCarta
@{
	ViewData["Title"] = "Maior Carta";
	Layout = "_Layout";
}

<link rel="stylesheet" href="~/css/jogo.css" />

<div class="jogo-container">
	<h1 class="titulo-jogo">Jogo de Maior Carta</h1>

	<div class="info-baralho">
		<p>ID do Baralho: @Model.Baralho.BaralhoId</p>
		<p>Cartas Restantes: @Model.Baralho.QuantidadeDeCartasRestantes</p>
		<p>Status: @(Model.Baralho.EstaEmbaralhado ? "Embaralhado" : "Não Embaralhado")</p>
		<div class="jogadores-contador">
			<p>Número de Jogadores: <span class="badge bg-success jogadores-badge">@Model.Jogadores.Count</span></p>
			<div class="jogadores-icones">
				@for (int i = 0; i < Model.Jogadores.Count; i++)
				{
					<div class="jogador-icone @(i == 0 ? "computador" : "humano")" title="@(i == 0 ? "Computador" : "Jogador")">
						<i class="bi @(i == 0 ? "bi-cpu" : "bi-person")"></i>
					</div>
				}
			</div>
		</div>
	</div>

	<div class="container">
		<div class="row justify-content-center">
			<div class="col-lg-10">
				<div class="card shadow">
					<div class="card-body">
						<div class="row">
							<div class="col-md-6">
								<div id="computer-area" class="text-center mb-4">
									<h3>Computador</h3>
									<div id="computer-cards" class="cartas-jogador">
										@if (Model.Jogadores[0].Cartas != null && Model.Jogadores[0].Cartas.Any())
										{
											foreach (var carta in Model.Jogadores[0].Cartas)
											{
												<partial name="_CartaPartial" model="carta" />
											}
										}
									</div>
									<div class="mt-2">
										<span class="badge bg-primary">Pontos: <span id="computer-score">0</span></span>
									</div>
								</div>
							</div>
							<div class="col-md-6">
								<div id="player-area" class="text-center mb-4">
									<h3>Você</h3>
									<div id="player-cards" class="cartas-jogador">
										@if (Model.Jogadores[1].Cartas != null && Model.Jogadores[1].Cartas.Any())
										{
											foreach (var carta in Model.Jogadores[1].Cartas)
											{
												<partial name="_CartaPartial" model="carta" />
											}
										}
									</div>
									<div class="mt-2">
										<span class="badge bg-primary">Pontos: <span id="player-score">0</span></span>
									</div>
								</div>
							</div>
						</div>

						<div class="text-center mt-4">
							<div id="message-area" class="alert alert-info mb-4" role="alert">
								Clique em "Jogar" para começar!
							</div>
							<button id="play-button" class="btn btn-primary btn-lg">
								<i class="bi bi-play-circle me-2"></i>Jogar
							</button>
						</div>
					</div>
				</div>

				<div class="card mt-4 shadow">
					<div class="card-body">
						<h4 class="card-title">Regras do Jogo</h4>
						<ul class="list-group list-group-flush">
							<li class="list-group-item">Cada jogador recebe uma carta aleatória</li>
							<li class="list-group-item">A carta com o valor mais alto vence</li>
							<li class="list-group-item">Ás (A) é a carta mais alta</li>
							<li class="list-group-item">Em caso de empate, o computador vence</li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

@section Scripts {
	<script>
		document.addEventListener('DOMContentLoaded', function() {
			const computerCards = document.getElementById('computer-cards');
			const playerCards = document.getElementById('player-cards');
			const computerScore = document.getElementById('computer-score');
			const playerScore = document.getElementById('player-score');
			const messageArea = document.getElementById('message-area');
			const playButton = document.getElementById('play-button');

			async function jogarRodada() {
				try {
					const response = await fetch(`/JogoWeb/DistribuirCartas?baralhoId=@Model.Baralho.BaralhoId&numeroJogadores=@Model.Jogadores.Count()`, {
						method: 'GET'
					});

					const result = await response.json();

					if (!result.success) {
						throw new Error(result.error);
					}

					const [computador, jogador] = result.data;

					// Limpar áreas de cartas
					computerCards.innerHTML = '';
					playerCards.innerHTML = '';

					// Exibir cartas usando a partial view via AJAX
					for (const carta of computador.cartas) {
						try {
							const cartaResponse = await fetch('/JogoWeb/RenderizarCarta', {
								method: 'POST',
								headers: {
									'Content-Type': 'application/json'
								},
								body: JSON.stringify({
									valor: carta.valor,
									valorSimbolico: carta.valorSimbolico,
									naipe: carta.naipe,
									codigo: carta.codigo,
									imagemUrl: carta.imagem
								})
							});

							if (cartaResponse.ok) {
								const cartaHtml = await cartaResponse.text();
								computerCards.insertAdjacentHTML('beforeend', cartaHtml);
							} else {
								console.error('Erro ao renderizar carta do computador:', await cartaResponse.text());
								messageArea.className = 'alert alert-danger';
								messageArea.textContent = 'Erro ao renderizar carta. Tente novamente.';
							}
						} catch (error) {
							console.error('Erro ao processar carta do computador:', error);
						}
					}
					for (const carta of jogador.cartas) {
						try {
							const cartaResponse = await fetch('/JogoWeb/RenderizarCarta', {
								method: 'POST',
								headers: {
									'Content-Type': 'application/json'
								},
								body: JSON.stringify({
									valor: carta.valor,
									valorSimbolico: carta.valorSimbolico,
									naipe: carta.naipe,
									codigo: carta.codigo,
									imagemUrl: carta.imagem
								})
							});

							if (cartaResponse.ok) {
								const cartaHtml = await cartaResponse.text();
								playerCards.insertAdjacentHTML('beforeend', cartaHtml);
							} else {
								console.error('Erro ao renderizar carta do jogador:', await cartaResponse.text());
								messageArea.className = 'alert alert-danger';
								messageArea.textContent = 'Erro ao renderizar carta. Tente novamente.';
							}
						} catch (error) {
							console.error('Erro ao processar carta do jogador:', error);
						}
					}

					// Determinar vencedor
					const computerMaxValue = Math.max(...computador.cartas.map(c => c.valor));
					const playerMaxValue = Math.max(...jogador.cartas.map(c => c.valor));

					if (computerMaxValue > playerMaxValue) {
						computerScore.textContent = parseInt(computerScore.textContent) + 1;
						messageArea.className = 'alert alert-danger';
						messageArea.textContent = 'Computador venceu esta rodada!';
					} else if (playerMaxValue > computerMaxValue) {
						playerScore.textContent = parseInt(playerScore.textContent) + 1;
						messageArea.className = 'alert alert-success';
						messageArea.textContent = 'Você venceu esta rodada!';
					} else {
						computerScore.textContent = parseInt(computerScore.textContent) + 1;
						messageArea.className = 'alert alert-warning';
						messageArea.textContent = 'Empate! Computador vence no desempate.';
					}

				} catch (error) {
					console.error('Erro:', error);
					messageArea.className = 'alert alert-danger';
					messageArea.textContent = 'Erro ao jogar a rodada. Tente novamente.';
				}
			}

			playButton.addEventListener('click', jogarRodada);
		});
	</script>

	<style>
		.jogadores-contador {
			background-color: #f1f9ff;
			border-radius: 8px;
			padding: 15px;
			margin-top: 15px;
			box-shadow: 0 2px 5px rgba(0,0,0,0.1);
		}

		.jogadores-badge {
			font-size: 1.2em;
			padding: 8px 12px;
			margin-left: 10px;
		}

		.jogadores-icones {
			display: flex;
			margin-top: 10px;
			gap: 15px;
			justify-content: center;
		}

		.jogador-icone {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.2em;
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
			transition: transform 0.3s ease;
		}

			.jogador-icone:hover {
				transform: scale(1.1);
			}

			.jogador-icone.computador {
				background-color: #e74c3c;
				color: white;
			}

			.jogador-icone.humano {
				background-color: #3498db;
				color: white;
			}
	</style>
} 